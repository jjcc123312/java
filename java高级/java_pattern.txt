1. 单例模式 singleton
保证一个类只有一个实例，并且提供一个访问该实例的全局访问点；
减少了系统资源消耗，优化了共享资源的访问；
1.1 饿汉式
线程安全的，调用效率高，不能实现延时加载（延时加载：不使用该对象时不会被创建）
使用static修饰的成员变量，类加载时，在链接的准备阶段就会分配内存空初始化默认值，初始化阶段，会创建实例；
并且类加载是线程安全的，虚拟机只会加载一次类；
1.2 懒汉式
线程安全的，调用效率不高，实现了延时加载；
1.3 双重检测锁
线程安全的，调用效率低（使用了synchronized），实现了延时加载；
问题所在：JVM机制问题，非原子性操作，可能会出现指令重排的操作导致出现空指针；
解决方法：使用volatile修饰成员变量；volatile：使用volatile修饰的成员变量，在写操作前，不会进行读的操作，并且禁止了JVM进行指令重排；
1.4 静态内部类
线程安全的，调用效率高，实现了延时加载；
外部类没有static，所以不会像饿汉式那样立即加载对象。
只有真正调用getInstance(),才会加载静态内部类。加载时是线程安全的，instance是static final修饰的，保证了内存只会有一个实例，而且只能被赋值一次，从而保证了线程安全性。
1.5 枚举
枚举本身就是一个单例，并且天然的防止了反射与反序列化创建对象的漏洞；
线程安全的，调用效率高，没有实现延时加载；

2. 工厂公式；factory
实现了创建者和调用者的分离；
2.1 简单工厂模式
用来生产同一等级结构中的任意产品，对于新增产品需要修改代码。
专门定义一个类用于创建其它实例对象；创建的对象通常都有共同的父类。
对于新增产品不修改代码的话无能为力。
2.2 工厂方法模式
用于生产同一产品等级接口中的固定产品，对于新增产品只需要增加新的类即可，符合OPC原则；
定义一个用于创建实例对象的接口，让子类决定实例哪一个类，工厂方法使得类的实例化延时到了子类；
定义一个产品类接口；
定义一个工厂类接口；
2.3 抽象工厂模式
产品族是指由同一个工厂创建的，位于不同产品等级结构的一组产品；
产品族可以生产不同产品等级结构的所有产品，对于新增产品，无法实现，支持新增产品族；
模式定义：
定义多个产品类的接口；
定义一个御用创建产品族的接口，接口中定义多个用于创建，不同产品等级结构的实例产品的方法；让子类决定实现哪个产品等级结构的哪种产品；

3. 原型模式 prototype
任何类想要支持克隆（深克隆外），必须实现Cloneable接口，重写clone()方法，克隆创建对象不会调用constructor，clone()是一个本地方法，直接操作二进制流，效率高；
clone对于基本数据类型及其包装类和String类型的变量，是直接复制的值；
浅克隆：
	对于基本数据类型和String类型的变量，会重新复制一份值，而对于引用指向的变量（数组，类的对象等），只是拷贝了一份引用，前后两个变量指向是的同一个对象；
深克隆：
	不仅对基本数据类型和String类型的变量，会重新复制一份值；同时对引用指向的对象进行拷贝（在clone()方法中对克隆对象的子类也进行克隆操作）；
完全克隆：
	实现Serializable接口，通过反序列化，将对象写入二进制流中，在从二进制流中读取出来；

4. 适配器模式 adapter
把一个类的接口变换成客户端所期待的另一种接口，从而使原本因为接口不兼容而无法一起工作的两个类可以一起工作；
三个角色：
	源（Adaptee）：需要被适配的类
	适配器（Adapter）：连接源和目标的中间对象；
	目标 (Target)：客户端所期待的值；
类适配器：
	适配器类继承源类，获得源类的所有信息，并实现目标接口；
对象适配器：
	使用组合方式代替继承，降低耦合度；在Adapter类中封装Adaptee，这里Adaptee与Adapter是组合关系；
接口适配器：
	如果不准备使用接口中的所有方法时，可以先定义一个抽象类并实现需要使用的接口，抽象类中重写接口的所有方法；
	定义一个子类继承抽象类，重写需要使用的方法；
	
5. 桥接模式 bridge
将抽象和行为实现放在两个不同的类层次中，使两个层次可以独立的改变；
通过使用组合，聚合以及继承等行为让不同的类承担不同的职责；
桥接模式替代多继承方案，减少了子类的个数；
抽象类与接口是组合关系，其实是调用者与被调用者关系；

将抽象和行为实现放在两个不同的类层次中，使两个层次可以独立的改变；
通过组合，聚合，继承等行为方式让不同的类承担不同的职责；
桥接模式替代多继承方案，减少了子类的个数；
抽象类与接口是组合关系，

6. 装饰器模式 decorator
无需通过继承增加子类就能扩展对象的新功能，使用组合方式代替继承，降低耦合度；
Component:
	抽象构建角色，真实对象和装饰对象共同的接口，这样，客户端就能以与真实对象相同的方式同装饰对象交互；
ConcreteComponent:
	具体的构建角色，真实对象；
	FileInputStream，FileOutPutStream
Decorator：
	装饰者角色，持有一个抽象构建的引用。装饰对象接受所有客户端的请求，并把这些请求转发给真实的对象。这样，就能在真实对象调用前后增加新的功能；
ConcreteDecotator：
	具体的装饰对象，负责给构建对象增加新的功能；
	
7. 组合模式 Composite
又叫部门整体模式，它创建了对象组的树状结构，将对象组合成树状结构以表示整体部分的层次关系；
组合模式依据树状结构来组合对象，用来表示部分以及整体层次；
组合模式使得用户对单个对象和组合对象访问具有一致性，组合能让客户以一致的方式处理个别对象以及组合对象；
Component:
	抽象构建角色，这是组合中对象的声明接口，定义叶子和容器的共同特性，在适当情况下，实现所有类共有的接口默认行为；
leaf：
	在组合中表示叶子节点，叶子节点没有子节点；
Composite：
	非叶子节点，用于存储子部件，在Composite中实现子部件的相关操作，比如增加，删除，有容器特种，可以包含子节点；
	
8. 观察者对象 observer
当一个对象的状态发生改变时，其相关依赖对象皆得到通知并被自动更新；
观察者模式主要用于1：N的通知。当一个对象（Subject，Observable）的状态变化时，他需要即时告知一系列对象（Observer）令他们做出响应。

9. 策略模式 strategy
定义一个算法族，分别封装起来，让他们之间可以互相替换，此模式让算法的变化独立于使用算法的客户；
策略模式对应于解决某一个问题的算法族，允许用户从该算法族中任意选择一个算法解决某一个问题，同时可以方便的更换算法或增加新的算法。并且由客户端决定调用哪个算法。
	1.把变化的代码从不变的代码中分离。
	2.使用组合方式代替继承。
	3.面向接口开发，而不是具体的实现
	4.对扩展开发，对修改关闭。
Context：
	定义一个类负责和具体的策略类交互；这样的话，具体的算法和直接的客户端调用分离了，使得算法可以独立于客户端独立的变化。
	
10. 职责链模式 chain of responsibility
又叫责任链模式，为请求创建一个接收者对象的处理链，该模式使得请求的发送者和接收者解耦；
责任链模式中通常每个接收者都包含另一个接收者的引用（单向链表特性，也可以使用容器存储接收者对象，比如SpringMVC的HandlerExecutionChain中，拿到了存储拦截器的容器，
拦截器就是用了职责链模式，HandlerExecutionChain只负责请求拦截器和请求处理），把处理同一类请求的对象连成一条链，所提交的请求沿着链传递，链上的对象逐个判断是否能处理该请求，能则处理，不能则传递给链上的下一个请求；
几个角色：
	Handler：
		抽象构建角色，所有具体处理者的父类；
	ConcreteHandler：
		真实构建角色，具体的处理者，处理它自己负责的请求，能则处理，不能则传递给链上的下一个请求；从而形成一条职责链；
	request:
		一个请求；
		
		
		
		
		

48小时
评价内容：自动评价












