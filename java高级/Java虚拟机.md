# Java虚拟机

## 1. JVM基本结构

<img src=".\img\1569379134930.png" alt="1569379134930" style="zoom:150%;" />

<img src=".\img\webp" alt="img" style="zoom:150%;" />

> 注意：java8开始已经取消了**方法区**，取而代之的是**元空间**

### 1.1 类加载子系统：

**类加载子系统负责从文件系统或者网络中加载`Class`信息**，加载的类信息**存放于一块称为方法区（java8开始为元空间）的内存空间**。除了类的信息外，方法区可能还会存放运行时常量池信息，包括~~字符串字面量~~和数字常量（这部分常量信息是Class文件常量池部分的内存映射）。

[java类加载器]: .\Java类加载器.md	"java类加载器"

### 1.2 ~~方法区~~（元空间）：

与java堆一样，是各个线程共享的区域，它用于存储已被类加载器加载的类信息：常量（**非字符串常量**），即时编译器编译后的代码等数据。**从jdk1.7已经开始准备“去永久代”的规划，jdk1.7的HotSpot中，已经把原本放在方法区中的静态变量、字符串常量池等移到堆内存中。**

**在jdk1.8中，永久代** **已经不存在，存储的类信息、编译后的代码数据,运行时常量池等已经移动到了元空间（MetaSpace）中，元空间并没有处于堆内存上，而是直接占用的本地内存（NativeMemory）。**

元空间的本质和永久代类似，都是对JVM规范中方法区的实现。不过**元空间与永久代之间最大的区别在于：元空间并不在虚拟机中，而是使用本地内存。因此，默认情况下，元空间的大小仅受本地内存限制，也不受GC的影响**

> **元空间里存储着class文件的信息和运行时常量池,class文件的信息包括类信息和class文件常量池，以及运行时常量池**；

![img](.\img\1212312451.png)

#### **1.2.1 三种情况：**

**Java1.8之前: **

![](.\img\20180821135022994.png)

**Java1.8之后: **

![](.\img\20180312125453153.jpg)

- **java7之前：**
  - 方法区即永久代位于java虚拟机内存中，方法区和java堆相互隔离，方法区里面存储了类加载器加载后的类信息：常量，静态变量，符号引用，即时编译器编译过后的代码等数据；
- **java7：**
  - jdk已经开始去永久代的规划；存储在方法区的部分数据已经转移到了java堆或者Native memory（本地内存）中；**字符串常量池和类的静态变量**转移存储到了java堆中；
- **java8：**
  - 取消永久代，取而代之的是元空间，**将方法区存放于元空间(Metaspace)，因而符号引用(Symbols)也转移存储到了Native memory中**，**元空间位于本地内存**，元空间仍然与java堆不相连，但与java堆共享物理内存，**当java heap空间不足时，会触发GC，但本地内存不足不会触发GC **
- **永久代向元空间转化的理由：**

  - 字符串存在永久代中，**容易出现性能问题和内存溢出。**
  - 将字符串常量池从PermGen分离出来，与**类元数据（描述数据的数据，譬如XML文件中的<title>标签）分开，提升类元数据的独立性**
  - 类及方法的信息等比较难确定其大小，因此对于永久代的大小指定比较困难，太小容易出现永久代溢出，太大则容易导致老年代溢出。
  - 在PermGen中元数据可能会随着每一次Full GC发生而进行移动。**HotSpot虚拟机的每种类型的垃圾回收器都需要特殊处理PermGen中的元数据，分离出来以后可以简化Full GC以及对以后的并发隔离类元数据等方面进行优化**。
  - 永久代会为 GC 带来不必要的复杂度，并且回收效率偏低。

### 1.3 Java堆

**java堆在虚拟机启动的时候建立**，它是java程序最主要的内存工作区域。**几乎所有的java对象实例都存放在java堆中。堆空间是所有线程共享的**，这是一块与java应用密切相关的内存空间。

**特点：**

1. 堆用于存储创建好的对象和数组
2. jvm只有一个堆，被所有线程共享
3. 堆是一个不连续性的内存空间，分配灵活，速度慢

**java堆内存分为`年轻代（Young Generation）`和`年老代（old Generation）`**。年轻代又分为两种：`Eden`区域，两个大小相等的`Survivor`区域。

所有新建的Object都会存放在`Young Generation`中。如果Young Generation的数据在一次或多次GC后存活下来，将会转移到Old Generation中。新的对象总是创建在Eden Generation；

堆空间内存分配（默认情况下）
老年代 ： 三分之二的堆空间
年轻代 ： 三分之一的堆空间 
eden区： 8/10 的年轻代空间
survivor0 : 1/10 的年轻代空间
survivor1 : 1/10 的年轻代空间
命令行上执行如下命令，查看所有默认的jvm参数
`java -XX:+PrintFlagsFinal -version`

`-XX:InitialSurvivorRatio`    新生代Eden/Survivor空间的初始比例
`-XX:Newratio    Old`区 和 `Yong`区 的内存比例

<img src=".\img\345531-20151115204320728-1210139023-1551797567453.png" alt="img" style="zoom:150%;" />

<img src=".\img\70" alt="heap" style="zoom:150%;" />

#### 年轻代：

所有新生成的对象首先都会存放在`Eden Generation`中，**年轻代的目标就是尽可能的快速收集掉那些声明周期短的对象。**年轻代分三个去，一个Eden区，两个大小相等的Survivor区（一般而言，可以配置多个）。大部分对象在Eden区中生成。

#### 年老代：

**在年轻代中经理了N次（默认15次）垃圾回收后仍然存活的对象，就会被放到年老代中。**因此，可以认为年老代中存放的都是一些生命周期较长的对象。

### 1.4 直接内存

java 的 NIO 库允许 java 程序使用直接内存。直接内存是在 java 堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于 java 堆。因此**出于性能的考虑，读写频繁的场合可能会考虑使用直接内存**。由于**直接内存在 java 堆外，因此它的大小不会直接受限于 Xmx 指定的最大堆大小**，但是系统内存是有限的，java 堆和直接内存的总和依然受限于操作系统能给出的最大内存。

### 1.5 垃圾回收系统

垃圾回收系统是 java 虚拟机的重要组成部分，**垃圾回收器可以对~~方法区~~、java 堆和直接内存进行回收。其中，java 堆是垃圾收集器的工作重点**。和 C/C++不同，java 中所有的对象空间释放都是隐式的，也就是说，java 中没有类似 free()或者 delete()这样的函数释放指定的内存区域。对于不再使用的垃圾对象，垃圾回收系统会在后台默默工作，默默查找、标识并释放垃圾对象，完成包括 java 堆、方法区和直接内存中的全自动化管理。

### 1.6 Java栈

**每一个 java 虚拟机线程都有一个私有的 java 栈，一个线程的 java 栈在线程创建的时候被创建**，java 栈中保存着帧信息，java 栈中保存着局部变量、方法参数，同时和 java 方法的调用、返回密切相关。

1. 栈描述的是方法执行的内存模型，**每个方法被调用都会创建一个栈帧**（局部变量表，操作数栈，指向运行时常量池的引用，方法返回地址等）
2. **JVM为每一个线程创建一个栈**，用于存放该线程执行方法的信息
3. **栈属于线程私有，不能实现线程间的共享**
4. 栈的储存特性是**先进后出，后进先出**；
5. 栈是由系统自动分配, 速度快!栈是一个连续的内存空间

#### 局部变量表

**用于存储方法中的局部变量（包括在方法中声明的非静态变量以及函数形参）**。对于**基本数据类型的变量，直接存储他的值，对于引用类型的变量，则存的是指向对象的引用**。局部变量表的大小在编译器就可以确定其大小，因此**在程序执行期间局部变量表的大小是不会改变的**。

#### 操作数栈

**栈最典型的一个应用就是用来对表达式求值**。想想一个线程执行方法的过程中，实际上就是不断执行语句的过程，而归根到底就是进行计算的过程。因此可以这么说，**程序中的所有计算过程都是在借助于操作数栈来完成的。**

#### 指向运行时常量池的引用

**在方法执行的过程中有可能用到类中的常量，所以必须要有一个引用指向运行时常量池。**

#### 方法返回地址

**当一个方法执行完毕之后，要返回之前调用它的地方，因此在栈帧中必须保存一个方法返回地址。**

###  1.7 本地方法栈

本地方法栈和 java 栈非常类似，最大的不同在于 **java 栈用于方法的调用，而本地方法栈则用于本地方法的调用**，作为对 java 虚拟机的重要扩展，java 虚拟机允许 java 直接调用本地方法（通常使用 C 编写）

### 1.8  PC  寄存器

也叫**程序计数器**，**寄存器是每个线程私有的空间，java虚拟机会为每一个java线程创建PC寄存器**。倘**若当前执行的是JVM方法，则该寄存器中保存当前执行指令的地址；倘若执行的是native方法，则PC寄存器为空。**

- 程序计数器是指CPU中的寄存器，**保存的是程序当前执行的指令的地址**（也可以说保存下一条指令的所在存储单元的地址）
- 在JVM中，多线程是通过线程轮流切换来获得CPU执行时间的，因此，在任一具体时刻，一个CPU的内核只会执行一条线程中的指令，所以PC寄存器是每个线程所私有的；
- 唯一一个在Java虚拟机规范中没有任何**OutOfMemoryError**的区域；

### 1.9 执行引擎

执行引擎是Java虚拟机的最核心组件之一，它负责**执行虚拟机中的字节码，或者执行本地方法**，现代虚拟机为了提高执行效率，会使用即时编译(just in time)技术**将方法编译成机器码后再执行**。





## 2. 常量池

用final修饰的变量表示常量，值一旦给定，无法改变；

修饰方法：该类不可被子类重写，可以被重载；

修饰类：无法被继承；

final修饰的变量有三种：静态变量、实例变量和局部变量，分别表示三种类型的常量。

java的常量池分为三种：

- Class常量池
- 运行时常量池
- String常量池

### 2.1 Class常量池

所处区域：class文件中

诞生时间：编译时

内容概要：符号引用( 符号引用包括：1.类的全限定名，2.字段名和描述，3.方法名和描述。)和字面量 （字符串，使用final修饰的基本数据类型，基本数据类型的值）

<img src=".\img\20141010133603275.png" alt="img" style="zoom:150%;" />

<img src=".\img\14141412213.png" alt="这里写图片描述" style="zoom:150%;" />

**class常量池是在编译的时候每个class都有的，在编译阶段，存放的是符号引用和常量**。class文件中除了包含类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池(constant pool table)，**用于存放编译器生成的各种字面量(Literal)和符号引用(Symbolic References)**。 字面量就是我们所说的常量概念，**如文本字符串、被声明为final的常量值等**。 **符号引用是一组符号来描述所引用的目标**，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可（它与直接引用区分一下，**直接引用一般是指向元空间的本地指针**，相对偏移量或是一个能间接定位到目标的句柄）。一般包括下面三类常量：

- 类和接口的全限定名
- 字段的名称和描述符
- 方法的名称和描述符

### 2.2 运行时常量池

所处区域：元空间

诞生时间：类加载器加载Class信息进入元空间时

**jvm在执行某个类的时候，必须经过加载、链接、初始化，而链接又包括验证、准备、解析三个阶段。而当类加载到内存中后，jvm就会将class常量池中的内容存放到运行时常量池中**，由此可知，**运行时常量池也是每个类都有一个**。class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析（resolve）之后，也就是把符号引用替换为直接引用，**解析的过程会去查询全局字符串池**，也就是我们所说的StringTable，以**保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的**。

运行时常量池是当class文件被加载完成后，**java虚拟机会将class文件常量池里的内容转移到运行时常量池里，在class文件常量池的符号引用有一部分是会被转变为直接引用的**，比如说类的静态方法或私有方法，实例构造方法，父类方法，这是因为这些方法不能被重写其他版本，所以能在加载的时候就可以将符号引用转变为直接引用，而其他的一些方法是在这个方法被第一次调用的时候才会将符号引用转变为直接引用的。

**运行时常量池里的内容除了是class文件常量池里的内容外，还将class文件常量池里的符号引用转变为直接引用，而且运行时常量池里的内容是能动态添加的**。例如调用String的intern方法就能将string的值添加到String常量池中。

### 2.3 字符串常量池

所处区域：java堆

诞生时间：**类加载完成，经过验证，准备后（类的初始化阶段）在堆中生成字符串对象实例，然后将引用存入string pool**

全局常量池里的类容是在**类加载完成，经过验证，准备阶段之后在堆中生成字符串对象实例，然后将该字符串对象实例的引用存入string pool中**（**字符串常量池存的是实例对象的引用，而不是具体的实例对象，具体的实例对象是在堆中开辟的一块空间存放的**）；在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个**StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。**

其实，“使用常量池”对应的字节码是一个 ldc 指令，**在给 String 类型的引用赋值的时候会先执行这个指令，看常量池中是否存在这个字符串对象的引用，若有就直接返回这个引用，若没有，就在堆里创建这个字符串对象并在字符串常量池中记录下这个引用（**jdk1.7)。**String 类的 intern() 方法还可在运行期间把字符串放到字符串常量池中。**

8种基本数据类型中除了两种浮点类型剩余的6种基本数据类型的包装类，都使用了缓冲池技术，但是 Byte、Short、Integer、Long、Character 这5种整型的包装类也只是在对应值在 [-128,127] 时才会使用缓冲池

### 总结：

- 字符串全局常量池在每个JVM中只有一份，存放的是字符串实例对象的引用
- class常量池是在class文件编译的时候就有的，在编译阶段存放的是符号引用和常量
- 运行时常量池是在类加载完成之后，将每个class常量池中的符号引用和常量转存到运行时常量池中，也就是说，每个class都有一个运行时常量池，**类在解析之后，将符号引用替换成直接引用**，对于字符串与全局常量池中的引用值保持一致。



## 3. JVM优化

## 常见 GC 的优化配置？

| 配置              | 描述                                     |
| :---------------- | :--------------------------------------- |
| -Xms              | 初始化堆内存大小                         |
| -Xmx              | 堆内存最大值                             |
| -Xmn              | 新生代大小                               |
| -XX:PermSize      | 初始化永久代大小                         |
| -XX:MaxPermSize   | 永久代最大容量                           |
| -XX:SurvivorRatio | 设置年轻代中 Eden 区与 Survivor 区的比值 |
| -XX:Xmn           | 设置年轻代大小                           |

另外，也可以看看 [《JVM 调优》](https://blog.csdn.net/zhaojw_420/article/details/70527138) 文章。

1. 查看gc日志
   1. 观察young gc、full gc的执行频率，以及gc时区域的内存使用情况
2. dump命令获取当前jvm堆的内存使用情况
   1. 注意需要事先下线dump的服务
   2. dump命令执行阶段，会暂停jvm，表现为全局停顿，所有Java代码停止，native代码可以执行，但不能与JVM交互。
   3. 可使用JProfile工具分析dump日志

https://blog.csdn.net/hu00848/article/details/123828518?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-123828518-blog-114143461.pc_relevant_3mothn_strategy_and_data_recovery&spm=1001.2101.3001.4242.2&utm_relevant_index=4

https://blog.csdn.net/weixin_42468413/article/details/114143461

https://blog.csdn.net/WZH577/article/details/109782827







## 4.垃圾回收

针对HotSpot VM的实现，它里面的GC其实准确分类只有两大种：

- Partial GC：并不收集整个GC堆的模式
  - Young GC：只收集young gen的GC
  - Old GC：只收集old gen的GC。只有`CMS`的concurrent collection是这个模式
  - Mixed GC：收集整个young gen以及部分old gen的GC。只有`G1`有这个模式
- Full GC：收集整个堆，包括young gen、old gen、perm gen（如果存在的话）等所有部分的模式。

Major GC通常是跟full GC是等价的，收集整个GC堆。但因为HotSpot VM发展了这么多年，外界对各种名词的解读已经完全混乱了，当有人说“major GC”的时候一定要问清楚他想要指的是上面的full GC还是old gen。

最简单的分代式GC策略，按HotSpot VM的serial GC的实现来看，触发条件是：

- young GC：当young gen中的eden区分配满的时候触发。注意young GC中有部分存活对象会晋升到old gen，所以young GC后old gen的占用量通常会有所升高。
- full GC：当准备要触发一次young GC时，如果发现统计数据说之前young GC的平均晋升大小比目前old gen剩余的空间大，则不会触发young GC而是转为触发full GC（因为HotSpot VM的GC里，除了CMS的concurrent collection之外，其它能收集old gen的GC都会同时收集整个GC堆，包括young gen，所以不需要事先触发一次单独的young GC）；或者，如果有perm gen的话，要在perm gen分配空间但已经没有足够空间时，也要触发一次full GC；或者System.gc()、heap dump带GC，默认也是触发full GC。

HotSpot VM里其它非并发GC的触发条件复杂一些，不过大致的原理与上面说的其实一样。
当然也总有例外。Parallel Scavenge（-XX:+UseParallelGC）框架下，默认是在要触发full GC前先执行一次young GC，并且两次GC之间能让应用程序稍微运行一小下，以期降低full GC的暂停时间（因为young GC会尽量清理了young gen的死对象，减少了full GC的工作量）。这是HotSpot VM里的奇葩嗯。

并发GC的触发条件就不太一样。以CMS GC为例，它主要是定时去检查old gen的使用量，当使用量超过了触发比例就会启动一次CMS GC，对old gen做并发收集。



### 4.1 什么是 Minor GC/Major GC

首先我们先科普一下JVM 经典的堆布局:

![img](https://markdown-images-leo.oss-cn-zhangjiakou.aliyuncs.com/typora_images/202210282131944.webp)

对于经典的 JVM heap 布局，有两个区域比较清晰，首先是Young 区,一般会来存放年轻的对象或者刚被创建没多久的对象。其次是 Old 区，也就是老年代，一般会来存放比较长寿的对象，或者从 young 区晋升的对象。

对于young 区 我们又有三个区域，一个是 Eden 区，还有两个大小相等的 Survivor 区。

新生的对象会在 Eden 区创建。

#### Minor GC

> minor gc又名Young GC，指发生在年轻代的垃圾回收

此时**如果新生的对象无法在 Eden 区创建（Eden 区无法容纳)** 就会触发一次Young GC 此时会将 S0 区与Eden 区的对象一起进行可达性分析，找出活跃的对象，将它复制到 S1 区并且将S0区域和 Eden 区的对象给清空，这样那些不可达的对象进行清除，并且将S0 区 和 S1区交换。

但是这里会产生一个问题，Q:为啥会有两个 Survivor 区？

A: 因为假设设想一下只有一个 Survibor 区 那么就无法实现对于 S0 区的垃圾收集，以及分代年龄的提升。

#### Major GC

> 注意，major gc可能单指old gen，也可能指full gc；不同的垃圾回收算法指定的区域不同。

> 发生在老年代的GC ，基本上发生了一次Major GC 就会发生一次 Minor GC。并且Major GC 的速度往往会比 Minor GC 慢 10 倍。

什么时候发生Major GC？

1. 对于一个大对象，我们会首先在Eden 尝试创建，如果创建不了，就会触发Minor GC
2. 随后继续尝试在Eden区存放，发现仍然放不下
3. 尝试直接进入老年代，老年代也放不下
4. 触发 Major GC 清理老年代的空间
5. 放的下 成功
6. 放不下 OOM

![img](https://markdown-images-leo.oss-cn-zhangjiakou.aliyuncs.com/typora_images/202210282135667.jpeg)

#### FULL GC

- **Major GC 是清理老年代。**
- **Full GC 是清理整个堆空间—包括年轻代和老年代。**

### 如何判断一个对象是否已经死去？

有两种方式：

1. 引用计数
2. 可达性分析

**1）引用计数**

每个对象有一个引用计数属性，新增一个引用时计数加 1 ，引用释放时计数减 1 ，计数为 0 时可以回收。此方法简单，无法解决对象相互循环引用的问题。目前在用的有 Python、ActionScript3 等语言。

**2）可达性分析（Reachability Analysis）**

从 GC Roots 开始向下搜索，搜索所走过的路径称为引用链。当一个对象到 GC Roots 没有任何引用链相连时，则证明此对象是不可用的。不可达对象。目前在用的有 Java、C# 等语言。

🦅 **如果 A 和 B 对象循环引用，是否可以被 GC？**

可以，因为 Java 采用可达性分析的判断方式。

🦅 **在 Java 语言里，可作为 GC Roots 的对象包括以下几种？**

1. 虚拟机栈（栈帧中的本地变量表）中引用的对象。
2. 方法区中的类静态属性引用的对象。
3. 方法区中常量引用的对象。
4. 本地方法栈中 JNI(即一般说的 Native 方法)中引用的对象。

🦅 **方法区是否能被回收？**

方法区可以被回收，但是价值很低，主要回收废弃的常量和无用的类。

如何判断无用的类，需要完全满足如下三个条件：

1. 该类所有实例都被回收（Java 堆中没有该类的对象）。
2. 加载该类的 ClassLoader 已经被回收。
3. 该类对应的 `java.lang.Class` 对象没有在任何地方被引用，无法在任何地方利用反射访问该类。

### JMV垃圾回收算法

有四种算法：

1. 标记-清除算法
2. 标记-整理算法
3. 复制算法
4. 分代收集算法

**1）标记-清除算法**

标记-清除（Mark-Sweep）算法，是现代垃圾回收算法的思想基础。

标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。

一种可行的实现是，在标记阶段，首先通过根节点，**标记所有从根节点开始的可达对象**。因此，未**被标记的对象就是未被引用的垃圾对象**（好多资料说标记出要回收的对象，其实明白大概意思就可以了）。然后，在**清除阶段，清除所有未被标记的对象**。

[![标记-清除算法](https://markdown-images-leo.oss-cn-zhangjiakou.aliyuncs.com/typora_images/202210291207129.jpeg)](http://static.iocoder.cn/f07ac7c68994aa21b7b4271073ea4e5b)标记-清除算法

- 缺点：
  - 1、效率问题，标记和清除两个过程的效率都不高。
  - 2、空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大的对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。

**2）标记-整理算法**

标记整理算法，**类似与标记清除算法**，不过它**标记完对象后，不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存**。

[![标记-整理算法](https://markdown-images-leo.oss-cn-zhangjiakou.aliyuncs.com/typora_images/202210291207048.jpeg)](http://static.iocoder.cn/52ea9a3813e09621c563b1cd4bdf0d22)标记-整理算法

- 优点：
  - 1、相对标记清除算法，解决了内存碎片问题。
  - 2、没有内存碎片后，对象创建内存分配也更快速了（可以使用TLAB进行分配）。
- 缺点：
  - 1、效率问题，（同标记清除算法）标记和整理两个过程的效率都不高。

**3）复制算法**

复制算法，可以解决效率问题，它**将可用内存按容量划分为大小相等的两块，每次只使用其中的一块，当这一块内存用完了，就将还存活着的对象复制到另一块上面，然后再把已经使用过的内存空间一次清理掉**，这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可（还可使用TLAB进行高效分配内存）。

[![复制算法](https://markdown-images-leo.oss-cn-zhangjiakou.aliyuncs.com/typora_images/202210291207007.jpeg)](http://static.iocoder.cn/cc3f228ca5353fd5deb4b22b7a9709e6)复制算法

- 图的上半部分是未回收前的内存区域，图的下半部分是回收后的内存区域。通过图，我们发现不管回收前还是回收后都有一半的空间未被利用。
- 优点：
  - 1、效率高，没有内存碎片。
- 缺点：
  - 1、浪费一半的内存空间。
  - 2、复制收集算法在对象存活率较高时就要进行较多的复制操作，效率将会变低。

**4）分代收集算法**

当前商业虚拟机都是采用分代收集算法，它根据对象存活周期的不同将内存划分为几块，一般是把 Java 堆分为新生代和老年代，然后根据各个年代的特点采用最适当的收集算法。

- 在新生代中，每次垃圾收集都发现有大批对象死去，只有少量存活，就选用复制算法。
- 而老年代中，因为对象存活率高，没有额外空间对它进行分配担保，就必须使用“标记清理”或者“标记整理”算法来进行回收。

[![分代收集算法](https://markdown-images-leo.oss-cn-zhangjiakou.aliyuncs.com/typora_images/202210291207096.jpeg)](http://static.iocoder.cn/fec52af474f1250831d46b541e0fe7a9)分代收集算法

- 图的左半部分是未回收前的内存区域，右半部分是回收后的内存区域。
- 对象分配策略：
  - 对象优先在 Eden 区域分配，如果对象过大直接分配到 Old 区域。
  - 长时间存活的对象进入到 Old 区域。
- 改进自复制算法
  - 现在的商业虚拟机都采用这种收集算法来回收新生代，IBM 公司的专门研究表明，新生代中的对象 98% 是“朝生夕死”的，所以并不需要按照 `1:1` 的比例来划分内存空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor 。当回收时，将 Eden 和 Survivor 中还存活着的对象一次性地复制到另外一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。
  - HotSpot 虚拟机默认 Eden 和 2 块 Survivor 的大小比例是 `8:1:1`，也就是每次新生代中可用内存空间为整个新生代容量的 90%（80%+10%），只有 10% 的内存会被“浪费”。当然，98% 的对象可回收只是一般场景下的数据，我们没有办法保证每次回收都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保（Handle Promotion）。

> 可以理解成：
>
> - 标记-清除算法是针对单个的对象进行回收（适合一次回收较少的对象）
> - 标记-整理算法是针对范围的对象进行回收（把标记过的引用对象放在一起，划分边界，然后清除内存区域中另一端所有的对象，适合回收不多不少的对象）
> - 复制算法是针对一个区域的对象进行回收（标记过的引用对象放到另一个内存区域，转而直接回收当前内存区域，适合一次性回收大量的对象）
> - 分代收集算法是针对jvm堆中不同区域的对象生命周期特性来进行合理的算法使用
>   - 年轻代中80%-90%的对象生命周期非常短，熬不过一次、二次GC，所以非常适合复制算法，一次GC可以回收非常多的对象
>   - 年老代中的对象生命周期都非常的长，一次GC段不可能回收多的对象，所以非常时候标记-清除、标记-整理算法 一次GC回收少量的对象

### JVM 垃圾收集器有哪些

如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。

- 新生代收集器
  - Serial 收集器
  - ParNew 收集器（ParNew 收集器，是 Serial 收集器的多线程版。）
  - Parallel Scavenge 收集器
- 老年代收集器
  - Serial Old 收集器
    - Serial Old 收集器，是 Serial 收集器的老年代版本。
  - Parallel Old 收集器
    - Parallel Old 收集器，是 Parallel Scavenge 收集器的老年代版本。
  - CMS 收集器
- 新生代 + 老年代收集器
  - G1 收集器
  - ZGC 收集器

小结表格如下：

| 收集器                | 串行、并行or并发 | 新生代/老年代 | 算法               | 目标         | 适用场景                                  |
| :-------------------- | :--------------- | :------------ | :----------------- | :----------- | :---------------------------------------- |
| **Serial**            | 串行             | 新生代        | 复制算法           | 响应速度优先 | 单CPU环境下的Client模式                   |
| **Serial Old**        | 串行             | 老年代        | 标记-整理          | 响应速度优先 | 单CPU环境下的Client模式、CMS的后备预案    |
| **ParNew**            | 并行             | 新生代        | 复制算法           | 响应速度优先 | 多CPU环境时在Server模式下与CMS配合        |
| **Parallel Scavenge** | 并行             | 新生代        | 复制算法           | 吞吐量优先   | 在后台运算而不需要太多交互的任务          |
| **Parallel Old**      | 并行             | 老年代        | 标记-整理          | 吞吐量优先   | 在后台运算而不需要太多交互的任务          |
| **CMS**               | 并发             | 老年代        | 标记-清除          | 响应速度优先 | 集中在互联网站或B/S系统服务端上的Java应用 |
| **G1**                | 并发             | both          | 标记-整理+复制算法 | 响应速度优先 | 面向服务端应用，将来替换CMS               |

> 客优云 年轻代使用`ParNew`回收器，年老代使用`CMS`回收器

🦅 **G1 和 CMS 的区别？**

- CMS ：并发标记清除。他的主要步骤有：初始收集，并发标记，重新标记，并发清除（删除）、重置。
- G1：主要步骤：初始标记，并发标记，重新标记，复制清除（整理）
- CMS 的缺点是对 CPU 的要求比较高。G1是将内存化成了多块，所有对内段的大小有很大的要求。
- CMS是清除，所以会存在很多的内存碎片。G1是整理，所以碎片空间较小。
- G1 和 CMS 都是响应优先把，他们的目的都是尽量控制 STW 时间。

> G1 和 CMS 的 Full GC 都是单线程 mark sweep compact 算法，直到 JDK10 才优化为并行的。

感兴趣的胖友，可以看看 [《GC 优化的一些总结》](http://engineering.xueqiu.com/blog/2015/06/25/jvm-gc-tuning/) 的分析。

🦅 **CMS 算法的过程，CMS 回收过程中 JVM 是否需要暂停？**

会有短暂的停顿。详细的，可以看看 [《[jvm\][面试] 并发收集器 CMS(Concurrent Mark-Sweep)》](https://blog.csdn.net/wfh6732/article/details/57490195) 。

🦅 **如何使用指定的垃圾收集器**

| 配置                    | 描述                                     |
| :---------------------- | :--------------------------------------- |
| -XX:+UserSerialGC       | 串行垃圾收集器                           |
| -XX:+UserParrallelGC    | 并行垃圾收集器                           |
| -XX:+UseConcMarkSweepGC | 并发标记扫描垃圾回收器                   |
| -XX:ParallelCMSThreads  | 并发标记扫描垃圾回收器 =为使用的线程数量 |
| -XX:+UseG1GC            | G1垃圾回收器                             |

### 对象分配规则是什么？

- 对象优先分配在 Eden 区。

  > 如果 Eden 区无法分配，那么尝试把活着的对象放到 Survivor0 中去（Minor GC）
  >
  > - 如果 Survivor0 可以放入，那么放入之后清除 Eden 区。
  > - 如果 Survivor0 不可以放入，那么尝试把 Eden 和 Survivor0 的存活对象放到 Survivor1 中。
  >   - 如果 Survivor1 可以放入，那么放入 Survivor1 之后清除 Eden 和 Survivor0 ，之后再把 Survivor1 中的对象复制到 Survivor0 中，保持 Survivor1 一直为空。
  >   - 如果 Survivor1 不可以放入，那么直接把它们放入到老年代中，并清除 Eden 和 Survivor0 ，这个过程也称为**分配担保**。
  >
  > ps：清除 Eden、Survivor 区，就是 Minor GC 。
  >
  > 总结来说，分配的顺序是：新生代（Eden => Survivor0 => Survivor1）=> 老年代

- 大对象直接进入老年代（大对象是指需要大量连续内存空间的对象）。

  > 这样做的目的是，避免在 Eden 区和两个 Survivor 区之间发生大量的内存拷贝（新生代采用复制算法收集内存）。

- 长期存活的对象进入老年代。

  > 虚拟机为每个对象定义了一个年龄计数器，如果对象经过了 1 次 Minor GC 那么对象会进入 Survivor 区，之后每经过一次 Minor GC 那么对象的年龄加 1 ，知道达到阀值对象进入老年区。

- 动态判断对象的年龄。

  > 为了更好的适用不同程序的内存情况，虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代。
  >
  > 如果 Survivor 区中相同年龄的所有对象大小的总和大于 Survivor 空间的一半，年龄大于或等于该年龄的对象可以直接进入老年代。

- 空间分配担保。

  > 每次进行 Minor GC 时，JVM 会计算 Survivor 区移至老年区的对象的平均大小，如果这个值大于老年区的剩余值大小则进行一次 Full GC ，如果小于检查 HandlePromotionFailure 设置，如果 `true` 则只进行 Monitor GC ，如果 `false` 则进行 Full GC 。

如下是一张对象创建时，分配内存的图：[![内存分配](https://markdown-images-leo.oss-cn-zhangjiakou.aliyuncs.com/typora_images/202210291307092.png)](http://static.iocoder.cn/bc22a30cbe93b8dedda080144a73b613)内存分配

🦅 **为什么新生代内存需要有两个 Survivor 区？**

详细的原因，可以看 [《为什么新生代内存需要有两个 Survivor 区》](https://blog.csdn.net/qq_27093465/article/details/79802884) 文章。

### 什么是新生代 GC 和老年代 GC？

GC 经常发生的区域是堆区，堆区还可以细分为

[![堆](https://markdown-images-leo.oss-cn-zhangjiakou.aliyuncs.com/typora_images/202210291333081.png)](http://static.iocoder.cn/67796f9fc657b7b4dd0054f561248f5b)堆

- 新生代
  - 一个 Eden 区
  - 两个 Survivor 区
- 老年代

> 默认新生代(Young)与老年代(Old)的比例的值为 `1:2` (该值可以通过参数 `–XX:NewRatio` 来指定)。
>
> 默认的 `Eden:from:to=8:1:1` (可以通过参数 `–XX:SurvivorRatio` 来设定)。

**新生代GC（MinorGC/YoungGC）**：指发生在新生代的垃圾收集动作，因为 Java 对象大多都具备朝生夕灭的特性，所以 MinorGC 非常频繁，一般回收速度也比较快。

**老年代GC（MajorGC/FullGC）**：指发生在老年代的 GC，出现了 MajorGC，经常会伴随至少一次的 MinorGC（但非绝对的，在 Parallel Scavenge 收集器的收集策略里就有直接进行 MajorGC 的策略选择过程）。MajorGC 的速度一般会比 MinorGC 慢 10 倍以上。

🦅 **什么情况下会出现 Young GC？**

对象优先在新生代 Eden 区中分配，如果 Eden 区没有足够的空间时，就会触发一次 Young GC 。

🦅 **什么情况下回出现 Full GC？**

Full GC 的触发条件有多个，FULL GC 的时候会 STOP THE WORD 。

- 1、在执行 Young GC 之前，JVM 会进行空间分配担保——如果老年代的连续空间小于新生代对象的总大小（或历次晋升的平均大小），则触发一次 Full GC 。
- 2、大对象直接进入老年代，从年轻代晋升上来的老对象，尝试在老年代分配内存时，但是老年代内存空间不够。
- 3、显式调用 `System#gc()` 方法时。

